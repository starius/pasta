// Code generated by gitlab.com/starius/lru-gen .
// Command: lru-gen -package database -key "uint64" -value "*Record"
// DO NOT EDIT!

package database

import "fmt"

type element struct {
	key        uint64
	value      *Record
	prev, next *element
	bytes      uint64
}

type LRU struct {
	maxSize, maxBytes, size, bytesUsed uint64

	m              map[uint64]*element
	newest, oldest *element
	removed        *element // Created in del(), removed in set().
}

func NewLRU(maxSize, maxBytes uint64) (*LRU, error) {
	if maxSize == 0 || maxBytes == 0 {
		return nil, fmt.Errorf("cache size must be > 0")
	}
	return &LRU{
		maxSize:  maxSize,
		maxBytes: maxBytes,
		m:        make(map[uint64]*element),
	}, nil
}

func (l *LRU) cut(e *element) {
	prev := e.prev
	next := e.next
	e.prev = nil
	e.next = nil
	if prev != nil && next != nil {
		prev.next = next
		next.prev = prev
	} else if prev != nil {
		// The element is the oldest element.
		prev.next = nil
		l.oldest = prev
	} else if next != nil {
		// The element is the newest element.
		next.prev = nil
		l.newest = next
	} else {
		// The element is the only element.
		l.newest = nil
		l.oldest = nil
	}
}

func (l *LRU) setNewest(e *element) {
	if l.newest == nil {
		l.newest = e
		l.oldest = e
	} else {
		e.next = l.newest
		l.newest.prev = e
		l.newest = e
	}
}

func (l *LRU) del(e *element) {
	delete(l.m, e.key)
	l.cut(e)
	l.size -= 1
	l.bytesUsed -= e.bytes
	e.value = nil
	l.removed = e
}

func (l *LRU) makeFreeSpace(bytes uint64) {
	for l.size+1 > l.maxSize || (l.size > 0 && l.bytesUsed+bytes > l.maxBytes) {
		l.del(l.oldest)
	}
}

func (l *LRU) Get(key uint64) (value *Record, has bool) {
	var e *element
	e, has = l.m[key]
	if !has {
		return
	}
	l.cut(e)
	l.setNewest(e)
	return e.value, true
}

func (l *LRU) Set(key uint64, value *Record, bytes uint64) (existed bool) {
	e, has := l.m[key]
	if has {
		l.del(e)
	}
	l.makeFreeSpace(bytes)
	e = l.removed
	if e == nil {
		e = &element{}
	}
	e.key = key
	e.value = value
	e.bytes = bytes
	l.m[key] = e
	l.size += 1
	l.bytesUsed += bytes
	l.setNewest(e)
	l.removed = nil
	return has
}

func (l *LRU) DeleteIfExists(key uint64) (existed bool) {
	e, has := l.m[key]
	if has {
		l.del(e)
	}
	return has
}
